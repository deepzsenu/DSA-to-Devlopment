## Longest Span in two Binary Arrays
Difficulty: MediumAccuracy: 48.22%Submissions: 19K+Points: 4
Given two binary arrays, a1[] and a2[]. Find the length of longest common span (i, j) where j>= i such that a1[i] + a1[i+1] + .... + a1[j] =  a2[i] + a2[i+1] + ... + a2[j].

#### Examples:

Input: a1[] = [0, 1, 0, 0, 0, 0], a2[] = [1, 0, 1, 0, 0, 1]
Output: 4
Explanation: The longest span with same sum is from index 1 to 4 following zero based indexing.
Input: a1[] = [0, 1, 0, 1, 1, 1, 1], a2[] = [1, 1, 1, 1, 1, 0, 1]
Output: 6
Explanation: The longest span with same sum is from index 1 to 6 following zero based indexing.
Constraints:
1 <= a1.size() = a2.size() <= 106
0 <= a1[i], a2[i] <= 1

Expected Complexities
Time Complexity: O(n)
Auxiliary Space: O(n)


Hereâ€™s the same solution with detailed comments explaining every step:

```python
class Solution:
    def longestCommonSum(self, a1, a2):
        n = len(a1)
        
        # Step 1: Create the difference array where each element
        # is the difference between corresponding elements of a1 and a2.
        # If sum over any subarray of diff[] is zero,
        # it means sum of a1 and a2 over that subarray are equal.
        diff = [a1[i] - a2[i] for i in range(n)]
        
        prefix_sum = 0  # This will store the cumulative sum of diff[]
        max_len = 0     # To keep track of the longest subarray length found
        
        # Dictionary to store the first occurrence index of each prefix_sum value
        prefix_index_map = {}
        
        for i in range(n):
            prefix_sum += diff[i]
            
            # If prefix_sum is zero, it means from start (index 0) to current index i,
            # the subarray sum is zero, so the longest length can be i+1
            if prefix_sum == 0:
                max_len = i + 1
                
            # If this prefix_sum has been seen before,
            # it means the sum of elements between the previous index + 1 to current i is zero
            if prefix_sum in prefix_index_map:
                # Calculate length of this zero-sum subarray
                current_len = i - prefix_index_map[prefix_sum]
                # Update max_len if we found a longer subarray
                if current_len > max_len:
                    max_len = current_len
            else:
                # Store the first occurrence of this prefix_sum
                prefix_index_map[prefix_sum] = i
        
        return max_len
```

---

### Why this works:

* When you take the difference of arrays element-wise, subarrays with equal sums in `a1` and `a2` correspond exactly to subarrays where the sum in `diff` is zero.
* Using a prefix sum array, if at two different indices the prefix sums are the same, the sum between those indices is zero.
* By storing the earliest index where each prefix sum occurs, you can quickly calculate the length of zero-sum subarrays as you traverse.
* The maximum such length found is the answer.

---


